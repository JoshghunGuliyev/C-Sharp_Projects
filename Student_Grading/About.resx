<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>The program will load data about students and their grades from a file.
It can be txt file that looks for example like this:

Johny Smith; 4; 4; 1; 3; 5; 2
Lucy Jenkins; 1; 2; 3; 1; 1; 1
Peter Johnson; 1; 1; 1; 1; 2; 1

The user can then choose to:
1. view the whole grading (every student and their grades)
2. enter student name and only grades for that student are shown
3. find the best / worst student (based on grade average)
4. enter a grade, and names of students who have better average are shown
5. calculate average for the whole class across all tests
6. calculate average for the whole class for a given test
	

BONUS:
1. Allow adding new tests / grading. If the uses decides to add new test, the program will display names of students and the user enters grades for each person for this new test. Afterwards, the new data is stored (overwrite the original file so that it has the added grades)
2. Allow multiple classes - so for example have one file with grades for Maths, one file with grades for Biology, one file for Chemistry etc... the user can choose which subject they want to "load"
3. Give user option to sort students based on their grades
</value>
  </data>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>1. Work (do what they’re supposed to do)
2. Be interactive (user inputs something, controls the program – user shouldn’t be just passive observer)
3. Be “multi-run” (they start over / one big cycle, at the end it asks if user wants to quit or start again, or have repeating menu with “exit” option)
Work with files (load / save data - .txt files are good enough)
4. Work with files (load / save data - .txt files are good enough)</value>
  </data>
  <data name="richTextBox3.Text" xml:space="preserve">
    <value>1. The program lets the user to see and manage Student Grading information
2. User can add/delete tests and students, add/modify test grades and see best/worst students, class or test average results changing after adding new records
3. User can close both "Subjects" and "Grades" windows and the program will prompt the question to confirm
4. The program pulls data from MS Access database file and saves changes to the same file</value>
  </data>
  <data name="richTextBox4.Text" xml:space="preserve">
    <value>The program loads data from MS Access database file.
It looks like this:
                         Test1   Test2    Test3
Johny Smith      4            4          5
Lucy Jenkins      5            3          3
Peter Johnson   5            4          4

Requirements fulfillment:
1. Loads after selecting subject
2. "Listing option" GroupBox and "By Student" field
3. "Statistics" GroupBox, Best/Worst Students ComboBox
4. "Listing option" GroupBox and "Above this avg" field
5. "Statistics" GroupBox, "Class Average" field
6. "Statistics" GroupBox, "Test Average" combobox
	

BONUS:
1. "Add/Delete" GroupBox for adding new tests/students and "Modify" GroupBox to add new grades or modify existing


2. At the beginning the program asks to user to select the subject to see the results.

3. "Listing Options" GroupBox and "Sort grades by" field serves to this requirement.
</value>
  </data>
</root>